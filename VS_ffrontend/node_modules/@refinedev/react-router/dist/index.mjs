// src/bindings.tsx
import React from "react";
import {
  matchResourceFromRoute,
  ResourceContext
} from "@refinedev/core";
import { useCallback, useContext } from "react";
import qs from "qs";
import {
  useNavigate,
  useLocation,
  Link,
  matchPath,
  useParams
} from "react-router";

// src/convert-to-number-if-possible.ts
var convertToNumberIfPossible = (value) => {
  if (typeof value === "undefined") {
    return value;
  }
  const num = Number(value);
  if (`${num}` === value) {
    return num;
  }
  return value;
};

// src/bindings.tsx
var stringifyConfig = {
  addQueryPrefix: true,
  skipNulls: true,
  arrayFormat: "indices",
  encode: false,
  encodeValuesOnly: true
};
var routerProvider = {
  go: () => {
    const { search: existingSearch, hash: existingHash } = useLocation();
    const navigate = useNavigate();
    const fn = useCallback(
      ({
        to,
        type,
        query,
        hash,
        options: { keepQuery, keepHash } = {}
      }) => {
        const urlQuery = {
          ...keepQuery && existingSearch && qs.parse(existingSearch, { ignoreQueryPrefix: true }),
          ...query
        };
        if (urlQuery.to) {
          urlQuery.to = encodeURIComponent(`${urlQuery.to}`);
        }
        const hasUrlQuery = Object.keys(urlQuery).length > 0;
        const urlHash = `#${(hash || keepHash && existingHash || "").replace(
          /^#/,
          ""
        )}`;
        const hasUrlHash = urlHash.length > 1;
        const urlTo = to || "";
        const fullPath = `${urlTo}${hasUrlQuery ? qs.stringify(urlQuery, stringifyConfig) : ""}${hasUrlHash ? urlHash : ""}`;
        if (type === "path") {
          return fullPath;
        }
        navigate(fullPath, {
          replace: type === "replace"
        });
        return;
      },
      [existingHash, existingSearch, navigate]
    );
    return fn;
  },
  back: () => {
    const navigate = useNavigate();
    const fn = useCallback(() => {
      navigate(-1);
    }, [navigate]);
    return fn;
  },
  parse: () => {
    var _a;
    let params = useParams();
    const { pathname, search } = useLocation();
    const { resources } = useContext(ResourceContext);
    const { resource, action, matchedRoute } = React.useMemo(() => {
      return matchResourceFromRoute(pathname, resources);
    }, [resources, pathname]);
    if (Object.entries(params).length === 0 && matchedRoute) {
      params = ((_a = matchPath(matchedRoute, pathname)) == null ? void 0 : _a.params) || {};
    }
    const fn = useCallback(() => {
      const parsedSearch = qs.parse(search, { ignoreQueryPrefix: true });
      const combinedParams = {
        ...params,
        ...parsedSearch
      };
      const response = {
        ...resource && { resource },
        ...action && { action },
        ...(params == null ? void 0 : params.id) && { id: decodeURIComponent(params.id) },
        // ...(params?.action && { action: params.action }), // lets see if there is a need for this
        pathname,
        params: {
          ...combinedParams,
          currentPage: convertToNumberIfPossible(
            combinedParams.currentPage
          ),
          pageSize: convertToNumberIfPossible(
            combinedParams.pageSize
          ),
          to: combinedParams.to ? decodeURIComponent(combinedParams.to) : void 0
        }
      };
      return response;
    }, [pathname, search, params, resource, action]);
    return fn;
  },
  Link: React.forwardRef(function RefineLink(props, ref) {
    return /* @__PURE__ */ React.createElement(Link, { to: props.to, ...props, ref });
  })
};

// src/navigate-to-resource.tsx
import { useResourceParams, useGetToPath } from "@refinedev/core";
import React2 from "react";
import { Navigate } from "react-router";
var NavigateToResource = ({
  resource: resourceProp,
  fallbackTo,
  meta
}) => {
  const getToPath = useGetToPath();
  const { resource, resources } = useResourceParams({
    resource: resourceProp
  });
  const toResource = resource || resources.find((r) => r.list);
  if (toResource) {
    const path = getToPath({
      resource: toResource,
      action: "list",
      meta
    });
    if (path) {
      return /* @__PURE__ */ React2.createElement(Navigate, { to: path });
    }
    return null;
  }
  if (fallbackTo) {
    console.warn(`No resource is found. navigation to ${fallbackTo}.`);
    return /* @__PURE__ */ React2.createElement(Navigate, { to: fallbackTo });
  }
  console.warn(
    'No resource and "fallbackTo" is found. No navigation will be made.'
  );
  return null;
};

// src/unsaved-changes-notifier.tsx
import React4 from "react";
import { useTranslate, useWarnAboutChange } from "@refinedev/core";

// src/use-prompt-workaround.ts
import React3 from "react";
import { UNSAFE_NavigationContext as NavigationContext } from "react-router";
function useConfirmExit(confirmExit, when = true) {
  const { navigator } = React3.useContext(NavigationContext);
  React3.useEffect(() => {
    if (!when) {
      return;
    }
    const go = navigator.go;
    const push = navigator.push;
    navigator.push = (...args) => {
      const result = confirmExit();
      if (result !== false) {
        push(...args);
      }
    };
    navigator.go = (...args) => {
      const result = confirmExit();
      if (result !== false) {
        go(...args);
      }
    };
    return () => {
      navigator.push = push;
      navigator.go = go;
    };
  }, [navigator, confirmExit, when]);
}
function usePrompt(message, when = true, onConfirm) {
  const warnWhenListener = React3.useCallback(
    (e) => {
      e.preventDefault();
      e.returnValue = message;
      return e.returnValue;
    },
    [message]
  );
  React3.useEffect(() => {
    if (when) {
      window.addEventListener("beforeunload", warnWhenListener);
    }
    return () => {
      window.removeEventListener("beforeunload", warnWhenListener);
    };
  }, [warnWhenListener, when]);
  const confirmExit = React3.useCallback(() => {
    const confirm = window.confirm(message);
    if (confirm && onConfirm) {
      onConfirm();
    }
    return confirm;
  }, [message]);
  useConfirmExit(confirmExit, when);
}

// src/unsaved-changes-notifier.tsx
import { useLocation as useLocation2 } from "react-router";
var UnsavedChangesNotifier = ({
  translationKey = "warnWhenUnsavedChanges",
  message = "Are you sure you want to leave? You have unsaved changes."
}) => {
  const translate = useTranslate();
  const { pathname } = useLocation2();
  const { warnWhen, setWarnWhen } = useWarnAboutChange();
  React4.useEffect(() => {
    return () => setWarnWhen == null ? void 0 : setWarnWhen(false);
  }, [pathname]);
  const warnMessage = React4.useMemo(() => {
    return translate(translationKey, message);
  }, [translationKey, message, translate]);
  usePrompt(warnMessage, warnWhen, () => {
    setWarnWhen == null ? void 0 : setWarnWhen(false);
  });
  return null;
};

// src/catch-all-navigate.tsx
import React5 from "react";
import { Navigate as Navigate2, useLocation as useLocation3 } from "react-router";
var CatchAllNavigate = ({ to }) => {
  const { pathname, search } = useLocation3();
  const queryValue = `${pathname}${search}`;
  const query = queryValue.length > 1 ? `?to=${encodeURIComponent(queryValue)}` : "";
  return /* @__PURE__ */ React5.createElement(Navigate2, { to: `${to}${query}` });
};

// src/document-title-handler.tsx
import {
  useParsed,
  useTranslate as useTranslate2,
  generateDefaultDocumentTitle,
  useUserFriendlyName
} from "@refinedev/core";
import React6, { useLayoutEffect } from "react";
import { useLocation as useLocation4 } from "react-router";
function DocumentTitleHandler({ handler }) {
  var _a;
  const location = useLocation4();
  const { action, id, params, pathname, resource } = useParsed();
  const translate = useTranslate2();
  const getUserFriendlyName = useUserFriendlyName();
  const identifier = (resource == null ? void 0 : resource.identifier) ?? (resource == null ? void 0 : resource.name);
  const preferredLabel = (_a = resource == null ? void 0 : resource.meta) == null ? void 0 : _a.label;
  const resourceName = preferredLabel ?? getUserFriendlyName(identifier, action === "list" ? "plural" : "singular");
  const populatedLabel = translate(
    `${resource == null ? void 0 : resource.name}.${resource == null ? void 0 : resource.name}`,
    resourceName
  );
  useLayoutEffect(() => {
    const autoGeneratedTitle = generateDefaultDocumentTitle(
      translate,
      resource,
      action,
      `${id}`,
      resourceName,
      getUserFriendlyName
    );
    if (handler) {
      document.title = handler({
        action,
        resource: {
          ...resource ?? {},
          meta: {
            ...resource == null ? void 0 : resource.meta,
            label: populatedLabel
          }
        },
        params,
        pathname,
        autoGeneratedTitle
      });
    } else {
      document.title = autoGeneratedTitle;
    }
  }, [location]);
  return /* @__PURE__ */ React6.createElement(React6.Fragment, null);
}

// src/use-document-title.ts
import { useTranslate as useTranslate3 } from "@refinedev/core";
import { useEffect } from "react";
var useDocumentTitle = (title) => {
  const translate = useTranslate3();
  useEffect(() => {
    if (!title)
      return;
    if (typeof title === "string") {
      document.title = translate(title);
    } else {
      document.title = translate(title.i18nKey);
    }
  }, [title]);
  return (title2) => {
    if (typeof title2 === "string") {
      document.title = translate(title2);
    } else {
      document.title = translate(title2.i18nKey);
    }
  };
};
export {
  CatchAllNavigate,
  DocumentTitleHandler,
  NavigateToResource,
  UnsavedChangesNotifier,
  routerProvider as default,
  stringifyConfig,
  useDocumentTitle
};
//# sourceMappingURL=index.mjs.map