// src/hooks/auth-header.before-request.hook.ts
var authHeaderBeforeRequestHook = (options) => async (req) => {
  const token = localStorage.getItem(options.ACCESS_TOKEN_KEY);
  if (token) {
    req.headers.set("Authorization", `Bearer ${token}`);
  }
};

// src/hooks/refresh-token.after-response.hook.ts
import ky from "ky";
var refreshTokenAfterResponseHook = (refineOptions) => async (request, _options, response) => {
  if (response.status === 401) {
    const currentRefreshToken = localStorage.getItem(
      refineOptions.REFRESH_TOKEN_KEY
    );
    try {
      const data = await ky(
        refineOptions.REFRESH_TOKEN_URL,
        {
          method: "post",
          body: JSON.stringify({ refreshToken: currentRefreshToken })
        }
      ).json();
      const accessToken = data.token;
      const refreshToken = data.refreshToken;
      localStorage.setItem(refineOptions.ACCESS_TOKEN_KEY, accessToken);
      localStorage.setItem(refineOptions.REFRESH_TOKEN_KEY, refreshToken);
      request.headers.set("Authorization", `token ${accessToken}`);
      return ky(request);
    } catch (e) {
      return response;
    }
  }
  return response;
};

// src/create-data-provider.ts
import dm from "deepmerge";
import kyBase from "ky";
import qs from "qs";

// src/default.options.ts
var defaultCreateDataProviderOptions = {
  getList: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      const { filters, sorters, pagination } = params;
      const queryParams = {
        filters,
        sorters,
        pagination,
        ...(_a = params.meta) == null ? void 0 : _a.query
      };
      return queryParams;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async getTotalCount(_response, _params) {
      return -1;
    }
  },
  getOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    }
  },
  create: {
    getEndpoint(params) {
      return params.resource;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({ ...body, variables: params.variables }),
        statusCode: response.status
      };
    }
  },
  update: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    getRequestMethod(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.method) ?? "patch";
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id,
          variables: params.variables
        }),
        statusCode: response.status
      };
    }
  },
  deleteOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(_response, _params) {
      return void 0;
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id
        }),
        statusCode: response.status
      };
    }
  },
  custom: {
    async buildQueryParams(params) {
      return params.query ?? {};
    },
    async buildHeaders(params) {
      return params.headers ?? {};
    },
    async buildBodyParams(params) {
      return params.payload ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          params
        }),
        statusCode: response.status
      };
    }
  }
};

// src/create-data-provider.ts
var createDataProvider = (apiURL, baseOptions = defaultCreateDataProviderOptions, kyOptions = {}) => {
  const options = dm(defaultCreateDataProviderOptions, baseOptions);
  const ky2 = kyBase.create({
    prefixUrl: apiURL,
    ...kyOptions,
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...kyOptions.headers
    },
    throwHttpErrors: false
  });
  return {
    kyInstance: ky2,
    dataProvider: {
      getList: async (params) => {
        const endpoint = options.getList.getEndpoint(params);
        const headers = await options.getList.buildHeaders(params);
        const query = await options.getList.buildQueryParams(params);
        const response = await ky2(endpoint, {
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getList.mapResponse(
          response.clone(),
          params
        );
        const total = await options.getList.getTotalCount(
          response.clone(),
          params
        );
        return { data, total };
      },
      getOne: async (params) => {
        const endpoint = options.getOne.getEndpoint(params);
        const headers = await options.getOne.buildHeaders(params);
        const query = await options.getOne.buildQueryParams(params);
        const response = await ky2(endpoint, {
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getOne.mapResponse(response, params);
        return { data };
      },
      getMany: options.getMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.getMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.getMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.getMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky2(endpoint, {
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.getMany.mapResponse(response, params);
          return { data };
        }
        let error;
        if (options.getMany.transformError) {
          error = await options.getMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      create: async (params) => {
        const endpoint = options.create.getEndpoint(params);
        const headers = await options.create.buildHeaders(params);
        const query = await options.create.buildQueryParams(params);
        const body = await options.create.buildBodyParams(params);
        const response = await ky2(endpoint, {
          method: "post",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.create.mapResponse(response, params);
          return { data };
        }
        const error = await options.create.transformError(response, params);
        throw error;
      },
      createMany: options.createMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const endpoint = ((_b = (_a = options.createMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.createMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.createMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.createMany.buildBodyParams(params);
        const response = await ky2(endpoint, {
          method: "post",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.createMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.createMany.transformError) {
          error = await ((_g = options.createMany) == null ? void 0 : _g.transformError(
            response,
            params
          ));
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      update: async (params) => {
        const endpoint = options.update.getEndpoint(params);
        const method = options.update.getRequestMethod(params);
        const headers = await options.update.buildHeaders(params);
        const query = await options.update.buildQueryParams(params);
        const body = await options.update.buildBodyParams(params);
        const response = await ky2(endpoint, {
          method,
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.update.mapResponse(response, params);
          return { data };
        }
        const error = await options.update.transformError(response, params);
        throw error;
      },
      updateMany: options.updateMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = options.updateMany.getEndpoint(params);
        const method = ((_b = (_a = options.updateMany).getRequestMethod) == null ? void 0 : _b.call(_a, params)) ?? "patch";
        const headers = await ((_d = (_c = options.updateMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.updateMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.updateMany.buildBodyParams(params);
        const response = await ky2(endpoint, {
          method,
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.updateMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.updateMany.transformError) {
          error = await options.updateMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      deleteOne: async (params) => {
        const endpoint = options.deleteOne.getEndpoint(params);
        const headers = await options.deleteOne.buildHeaders(params);
        const query = await options.deleteOne.buildQueryParams(params);
        const response = await ky2(endpoint, {
          method: "delete",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.deleteOne.mapResponse(response, params);
          return { data };
        }
        const error = await options.deleteOne.transformError(response, params);
        throw error;
      },
      deleteMany: options.deleteMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.deleteMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.deleteMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.deleteMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky2(endpoint, {
          method: "delete",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        if (options.deleteMany.mapResponse) {
          const data = await options.deleteMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        return { data: void 0 };
      } : void 0,
      custom: async (params) => {
        const { method, url } = params;
        let client = kyBase.create({
          method,
          ...kyOptions
        });
        const headers = await options.custom.buildHeaders(params);
        if (headers) {
          client = client.extend({ headers });
        }
        const query = await options.custom.buildQueryParams(params);
        if (query) {
          client = client.extend({
            searchParams: qs.stringify(query, { encodeValuesOnly: true })
          });
        }
        if (["post", "put", "patch"].includes(method)) {
          const body = await options.custom.buildBodyParams(params);
          if (body) {
            client = client.extend({ body: JSON.stringify(body) });
          }
        }
        const response = await client(url);
        if (response.ok) {
          const data = await options.custom.mapResponse(response, params);
          return { data };
        }
        const error = await options.custom.transformError(response, params);
        throw error;
      },
      getApiUrl: () => apiURL
    }
  };
};
export {
  authHeaderBeforeRequestHook,
  createDataProvider,
  refreshTokenAfterResponseHook
};
//# sourceMappingURL=index.mjs.map