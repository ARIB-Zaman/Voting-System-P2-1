// src/create-data-provider.ts
import dm from "deepmerge";
import kyBase from "ky";
import qs from "qs";

// src/default.options.ts
var defaultCreateDataProviderOptions = {
  getList: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      const { filters, sorters, pagination } = params;
      const queryParams = {
        filters,
        sorters,
        pagination,
        ...(_a = params.meta) == null ? void 0 : _a.query
      };
      return queryParams;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async getTotalCount(_response, _params) {
      return -1;
    }
  },
  getOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    }
  },
  create: {
    getEndpoint(params) {
      return params.resource;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({ ...body, variables: params.variables }),
        statusCode: response.status
      };
    }
  },
  update: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    getRequestMethod(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.method) ?? "patch";
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id,
          variables: params.variables
        }),
        statusCode: response.status
      };
    }
  },
  deleteOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(_response, _params) {
      return void 0;
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id
        }),
        statusCode: response.status
      };
    }
  },
  custom: {
    async buildQueryParams(params) {
      return params.query ?? {};
    },
    async buildHeaders(params) {
      return params.headers ?? {};
    },
    async buildBodyParams(params) {
      return params.payload ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          params
        }),
        statusCode: response.status
      };
    }
  }
};

// src/create-data-provider.ts
var createDataProvider = (apiURL, baseOptions = defaultCreateDataProviderOptions, kyOptions = {}) => {
  const options = dm(defaultCreateDataProviderOptions, baseOptions);
  const ky = kyBase.create({
    prefixUrl: apiURL,
    ...kyOptions,
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...kyOptions.headers
    },
    throwHttpErrors: false
  });
  return {
    kyInstance: ky,
    dataProvider: {
      getList: async (params) => {
        const endpoint = options.getList.getEndpoint(params);
        const headers = await options.getList.buildHeaders(params);
        const query = await options.getList.buildQueryParams(params);
        const response = await ky(endpoint, {
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getList.mapResponse(
          response.clone(),
          params
        );
        const total = await options.getList.getTotalCount(
          response.clone(),
          params
        );
        return { data, total };
      },
      getOne: async (params) => {
        const endpoint = options.getOne.getEndpoint(params);
        const headers = await options.getOne.buildHeaders(params);
        const query = await options.getOne.buildQueryParams(params);
        const response = await ky(endpoint, {
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getOne.mapResponse(response, params);
        return { data };
      },
      getMany: options.getMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.getMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.getMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.getMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky(endpoint, {
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.getMany.mapResponse(response, params);
          return { data };
        }
        let error;
        if (options.getMany.transformError) {
          error = await options.getMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      create: async (params) => {
        const endpoint = options.create.getEndpoint(params);
        const headers = await options.create.buildHeaders(params);
        const query = await options.create.buildQueryParams(params);
        const body = await options.create.buildBodyParams(params);
        const response = await ky(endpoint, {
          method: "post",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.create.mapResponse(response, params);
          return { data };
        }
        const error = await options.create.transformError(response, params);
        throw error;
      },
      createMany: options.createMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const endpoint = ((_b = (_a = options.createMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.createMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.createMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.createMany.buildBodyParams(params);
        const response = await ky(endpoint, {
          method: "post",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.createMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.createMany.transformError) {
          error = await ((_g = options.createMany) == null ? void 0 : _g.transformError(
            response,
            params
          ));
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      update: async (params) => {
        const endpoint = options.update.getEndpoint(params);
        const method = options.update.getRequestMethod(params);
        const headers = await options.update.buildHeaders(params);
        const query = await options.update.buildQueryParams(params);
        const body = await options.update.buildBodyParams(params);
        const response = await ky(endpoint, {
          method,
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.update.mapResponse(response, params);
          return { data };
        }
        const error = await options.update.transformError(response, params);
        throw error;
      },
      updateMany: options.updateMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = options.updateMany.getEndpoint(params);
        const method = ((_b = (_a = options.updateMany).getRequestMethod) == null ? void 0 : _b.call(_a, params)) ?? "patch";
        const headers = await ((_d = (_c = options.updateMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.updateMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.updateMany.buildBodyParams(params);
        const response = await ky(endpoint, {
          method,
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.updateMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.updateMany.transformError) {
          error = await options.updateMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      deleteOne: async (params) => {
        const endpoint = options.deleteOne.getEndpoint(params);
        const headers = await options.deleteOne.buildHeaders(params);
        const query = await options.deleteOne.buildQueryParams(params);
        const response = await ky(endpoint, {
          method: "delete",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.deleteOne.mapResponse(response, params);
          return { data };
        }
        const error = await options.deleteOne.transformError(response, params);
        throw error;
      },
      deleteMany: options.deleteMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.deleteMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.deleteMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.deleteMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky(endpoint, {
          method: "delete",
          headers,
          searchParams: qs.stringify(query, { encodeValuesOnly: true })
        });
        if (options.deleteMany.mapResponse) {
          const data = await options.deleteMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        return { data: void 0 };
      } : void 0,
      custom: async (params) => {
        const { method, url } = params;
        let client = kyBase.create({
          method,
          ...kyOptions
        });
        const headers = await options.custom.buildHeaders(params);
        if (headers) {
          client = client.extend({ headers });
        }
        const query = await options.custom.buildQueryParams(params);
        if (query) {
          client = client.extend({
            searchParams: qs.stringify(query, { encodeValuesOnly: true })
          });
        }
        if (["post", "put", "patch"].includes(method)) {
          const body = await options.custom.buildBodyParams(params);
          if (body) {
            client = client.extend({ body: JSON.stringify(body) });
          }
        }
        const response = await client(url);
        if (response.ok) {
          const data = await options.custom.mapResponse(response, params);
          return { data };
        }
        const error = await options.custom.transformError(response, params);
        throw error;
      },
      getApiUrl: () => apiURL
    }
  };
};

// src/data-providers/strapi-v4/utils/mapOperator.ts
var mapOperator = (operator) => {
  switch (operator) {
    case "startswith":
      return "startsWith";
    case "endswith":
      return "endsWith";
    case "nin":
      return "notIn";
    case "ncontains":
      return "notContainsi";
    case "ncontainss":
      return "notContains";
    case "containss":
      return "contains";
    case "contains":
      return "containsi";
    case "nnull":
      return "notNull";
  }
  return operator;
};

// src/data-providers/strapi-v4/utils/generateFilter.ts
var generateNestedFilterField = (field) => {
  if (field.startsWith("[") && field.endsWith("]")) {
    const matches = field.match(/\[([^\]]+)\]/g);
    if (matches) {
      return matches.map((match) => match.slice(1, -1));
    }
  }
  return field.split(".");
};
var generateLogicalFilter = (filter) => {
  const { field, operator, value } = filter;
  const mappedOperator = mapOperator(operator);
  const fieldPath = generateNestedFilterField(field);
  const filterObj = {};
  let current = filterObj;
  for (let i = 0; i < fieldPath.length - 1; i++) {
    current[fieldPath[i]] = {};
    current = current[fieldPath[i]];
  }
  current[fieldPath[fieldPath.length - 1]] = { [`$${mappedOperator}`]: value };
  return filterObj;
};
var mergeFilters = (target, source) => {
  for (const key in source) {
    if (key in target) {
      if (typeof target[key] === "object" && typeof source[key] === "object") {
        target[key] = mergeFilters(target[key], source[key]);
      }
    } else {
      target[key] = source[key];
    }
  }
  return target;
};
var generateConditionalFilter = (filter) => {
  const result = {};
  const operatorKey = `$${filter.operator}`;
  const subFilters = filter.value.map((item) => {
    if (item.operator !== "or" && item.operator !== "and" && "field" in item) {
      return generateLogicalFilter(item);
    }
    return generateConditionalFilter(item);
  });
  result[operatorKey] = subFilters;
  return result;
};
var generateFilter = (filters) => {
  if (!filters || filters.length === 0) {
    return {};
  }
  let result = {};
  filters.forEach((filter) => {
    let filterObj;
    if (filter.operator !== "or" && filter.operator !== "and" && "field" in filter) {
      filterObj = generateLogicalFilter(filter);
    } else {
      filterObj = generateConditionalFilter(filter);
    }
    result = mergeFilters(result, filterObj);
  });
  return result;
};

// src/data-providers/strapi-v4/utils/normalizeData.ts
var flatten = (data) => {
  if (!data.attributes)
    return data;
  return {
    id: data.id,
    ...data.attributes
  };
};
var isObject = (data) => Object.prototype.toString.call(data) === "[object Object]";
var normalizeData = (data) => {
  if (Array.isArray(data)) {
    return data.map((item) => normalizeData(item));
  }
  if (isObject(data)) {
    if (Array.isArray(data.data)) {
      data = [...data.data];
    } else if (isObject(data.data)) {
      data = flatten({ ...data.data });
    } else if (data.data === null) {
      data = null;
    } else {
      data = flatten(data);
    }
    for (const key in data) {
      data[key] = normalizeData(data[key]);
    }
    return data;
  }
  return data;
};

// src/data-providers/strapi-v4/utils/transformErrorMessages.ts
var transformErrorMessages = (errorMessages) => {
  const transformedErrors = {};
  for (const error of errorMessages) {
    const key = error.path[0];
    if (transformedErrors[key]) {
      transformedErrors[key].push(error.message);
    } else {
      transformedErrors[key] = [error.message];
    }
  }
  return transformedErrors;
};

// src/data-providers/strapi-v4/utils/transformHttpError.ts
var transformHttpError = (err) => {
  var _a;
  const error = err || {};
  const message = error == null ? void 0 : error.message;
  const statusCode = error == null ? void 0 : error.status;
  const errorMessages = ((_a = error == null ? void 0 : error.details) == null ? void 0 : _a.errors) || [];
  const httpError = {
    statusCode,
    message,
    errors: transformErrorMessages(errorMessages)
  };
  return httpError;
};

// src/data-providers/strapi-v4/strapi-v4.options.ts
var strapiV4DataProviderOptions = {
  getList: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildFilters(params) {
      const { filters = [] } = params;
      const queryFilters = generateFilter(filters);
      return queryFilters;
    },
    async buildPagination(params) {
      const {
        currentPage = 1,
        pageSize = 10,
        mode = "server"
      } = params.pagination ?? {};
      if (mode === "server") {
        return {
          page: currentPage,
          pageSize
        };
      }
      return {};
    },
    async buildSorters(params) {
      const { sorters = [] } = params;
      const _sorters = [];
      if (sorters) {
        sorters.forEach((item) => {
          if (item.order) {
            _sorters.push(`${item.field}:${item.order}`);
          }
        });
      }
      const sort = _sorters.length ? _sorters.join(",") : void 0;
      return { sort };
    },
    async buildQueryParams(params) {
      const filters = await this.buildFilters(params);
      const { sort } = await this.buildSorters(params);
      const pagination = await this.buildPagination(params);
      const { meta } = params;
      const locale = meta == null ? void 0 : meta.locale;
      const fields = meta == null ? void 0 : meta.fields;
      const populate = meta == null ? void 0 : meta.populate;
      const publicationState = meta == null ? void 0 : meta.publicationState;
      const queryParams = {
        pagination,
        locale,
        publicationState,
        fields,
        populate,
        sort,
        filters
      };
      return queryParams;
    },
    async mapResponse(response, params) {
      const body = await response.json();
      return normalizeData(body);
    },
    async getTotalCount(response, params) {
      var _a, _b, _c;
      const body = await response.json();
      return ((_b = (_a = body.meta) == null ? void 0 : _a.pagination) == null ? void 0 : _b.total) || ((_c = normalizeData(body)) == null ? void 0 : _c.length);
    }
  },
  getOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      const { meta } = params ?? {};
      const locale = meta == null ? void 0 : meta.locale;
      const fields = meta == null ? void 0 : meta.fields;
      const populate = meta == null ? void 0 : meta.populate;
      const publicationState = meta == null ? void 0 : meta.publicationState;
      const queryParams = {
        locale,
        fields,
        populate,
        publicationState
      };
      return queryParams;
    },
    async mapResponse(response, params) {
      const body = await response.json();
      return normalizeData(body);
    }
  },
  getMany: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      const { ids, meta } = params ?? {};
      const locale = meta == null ? void 0 : meta.locale;
      const fields = meta == null ? void 0 : meta.fields;
      const populate = meta == null ? void 0 : meta.populate;
      const publicationState = meta == null ? void 0 : meta.publicationState;
      const filters = generateFilter([
        { field: "id", operator: "in", value: ids }
      ]);
      const query = {
        locale,
        fields,
        populate,
        publicationState,
        filters,
        pagination: { pageSize: ids.length }
      };
      return query;
    },
    async mapResponse(response, params) {
      const body = await response.json();
      return normalizeData(body);
    }
  },
  create: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildBodyParams(params) {
      const { resource, variables } = params;
      let bodyParams = { data: variables };
      if (resource === "users") {
        bodyParams = variables;
      }
      return bodyParams;
    },
    async mapResponse(response, _params) {
      if (response.status >= 400) {
        const httpError = transformHttpError(response);
        throw httpError;
      }
      const body = await response.json();
      return body;
    }
  },
  update: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    getRequestMethod(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.method) ?? "put";
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      const { resource, variables } = params;
      let bodyParams = { data: variables };
      if (resource === "users") {
        bodyParams = variables;
      }
      return bodyParams;
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  deleteOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(_response, _params) {
      return void 0;
    }
  },
  custom: {
    async buildQueryParams(params) {
      const queryParams = {};
      if (params.sorters) {
        const _sorters = [];
        if (params.sorters) {
          params.sorters.forEach((item) => {
            if (item.order) {
              _sorters.push(`${item.field}:${item.order}`);
            }
          });
        }
        const sort = _sorters.length ? _sorters.join(",") : void 0;
        Object.assign(queryParams, { sort });
      }
      if (params.filters) {
        const queryFilters = generateFilter(params.filters);
        Object.assign(queryParams, { filters: queryFilters });
      }
      return queryParams;
    },
    async buildHeaders(params) {
      return params.headers ?? {};
    },
    async buildBodyParams(params) {
      return params.payload ?? {};
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  }
};

// src/data-providers/strapi-v4/index.ts
var createStrapiV4DataProvider = (params) => {
  const { apiURL, kyOptions } = params;
  return createDataProvider(apiURL, strapiV4DataProviderOptions, kyOptions);
};
export {
  createStrapiV4DataProvider
};
//# sourceMappingURL=strapi-v4.mjs.map