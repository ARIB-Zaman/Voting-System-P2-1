var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/data-providers/simple-rest/index.ts
var simple_rest_exports = {};
__export(simple_rest_exports, {
  createSimpleRestDataProvider: () => createSimpleRestDataProvider
});
module.exports = __toCommonJS(simple_rest_exports);

// src/create-data-provider.ts
var import_deepmerge = __toESM(require("deepmerge"));
var import_ky = __toESM(require("ky"));
var import_qs = __toESM(require("qs"));

// src/default.options.ts
var defaultCreateDataProviderOptions = {
  getList: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      const { filters, sorters, pagination } = params;
      const queryParams = {
        filters,
        sorters,
        pagination,
        ...(_a = params.meta) == null ? void 0 : _a.query
      };
      return queryParams;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async getTotalCount(_response, _params) {
      return -1;
    }
  },
  getOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    }
  },
  create: {
    getEndpoint(params) {
      return params.resource;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({ ...body, variables: params.variables }),
        statusCode: response.status
      };
    }
  },
  update: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    getRequestMethod(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.method) ?? "patch";
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id,
          variables: params.variables
        }),
        statusCode: response.status
      };
    }
  },
  deleteOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(_response, _params) {
      return void 0;
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id
        }),
        statusCode: response.status
      };
    }
  },
  custom: {
    async buildQueryParams(params) {
      return params.query ?? {};
    },
    async buildHeaders(params) {
      return params.headers ?? {};
    },
    async buildBodyParams(params) {
      return params.payload ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          params
        }),
        statusCode: response.status
      };
    }
  }
};

// src/create-data-provider.ts
var createDataProvider = (apiURL, baseOptions = defaultCreateDataProviderOptions, kyOptions = {}) => {
  const options = (0, import_deepmerge.default)(defaultCreateDataProviderOptions, baseOptions);
  const ky = import_ky.default.create({
    prefixUrl: apiURL,
    ...kyOptions,
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...kyOptions.headers
    },
    throwHttpErrors: false
  });
  return {
    kyInstance: ky,
    dataProvider: {
      getList: async (params) => {
        const endpoint = options.getList.getEndpoint(params);
        const headers = await options.getList.buildHeaders(params);
        const query = await options.getList.buildQueryParams(params);
        const response = await ky(endpoint, {
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getList.mapResponse(
          response.clone(),
          params
        );
        const total = await options.getList.getTotalCount(
          response.clone(),
          params
        );
        return { data, total };
      },
      getOne: async (params) => {
        const endpoint = options.getOne.getEndpoint(params);
        const headers = await options.getOne.buildHeaders(params);
        const query = await options.getOne.buildQueryParams(params);
        const response = await ky(endpoint, {
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getOne.mapResponse(response, params);
        return { data };
      },
      getMany: options.getMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.getMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.getMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.getMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky(endpoint, {
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.getMany.mapResponse(response, params);
          return { data };
        }
        let error;
        if (options.getMany.transformError) {
          error = await options.getMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      create: async (params) => {
        const endpoint = options.create.getEndpoint(params);
        const headers = await options.create.buildHeaders(params);
        const query = await options.create.buildQueryParams(params);
        const body = await options.create.buildBodyParams(params);
        const response = await ky(endpoint, {
          method: "post",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.create.mapResponse(response, params);
          return { data };
        }
        const error = await options.create.transformError(response, params);
        throw error;
      },
      createMany: options.createMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const endpoint = ((_b = (_a = options.createMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.createMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.createMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.createMany.buildBodyParams(params);
        const response = await ky(endpoint, {
          method: "post",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.createMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.createMany.transformError) {
          error = await ((_g = options.createMany) == null ? void 0 : _g.transformError(
            response,
            params
          ));
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      update: async (params) => {
        const endpoint = options.update.getEndpoint(params);
        const method = options.update.getRequestMethod(params);
        const headers = await options.update.buildHeaders(params);
        const query = await options.update.buildQueryParams(params);
        const body = await options.update.buildBodyParams(params);
        const response = await ky(endpoint, {
          method,
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.update.mapResponse(response, params);
          return { data };
        }
        const error = await options.update.transformError(response, params);
        throw error;
      },
      updateMany: options.updateMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = options.updateMany.getEndpoint(params);
        const method = ((_b = (_a = options.updateMany).getRequestMethod) == null ? void 0 : _b.call(_a, params)) ?? "patch";
        const headers = await ((_d = (_c = options.updateMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.updateMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.updateMany.buildBodyParams(params);
        const response = await ky(endpoint, {
          method,
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.updateMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.updateMany.transformError) {
          error = await options.updateMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      deleteOne: async (params) => {
        const endpoint = options.deleteOne.getEndpoint(params);
        const headers = await options.deleteOne.buildHeaders(params);
        const query = await options.deleteOne.buildQueryParams(params);
        const response = await ky(endpoint, {
          method: "delete",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.deleteOne.mapResponse(response, params);
          return { data };
        }
        const error = await options.deleteOne.transformError(response, params);
        throw error;
      },
      deleteMany: options.deleteMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.deleteMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.deleteMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.deleteMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky(endpoint, {
          method: "delete",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        if (options.deleteMany.mapResponse) {
          const data = await options.deleteMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        return { data: void 0 };
      } : void 0,
      custom: async (params) => {
        const { method, url } = params;
        let client = import_ky.default.create({
          method,
          ...kyOptions
        });
        const headers = await options.custom.buildHeaders(params);
        if (headers) {
          client = client.extend({ headers });
        }
        const query = await options.custom.buildQueryParams(params);
        if (query) {
          client = client.extend({
            searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
          });
        }
        if (["post", "put", "patch"].includes(method)) {
          const body = await options.custom.buildBodyParams(params);
          if (body) {
            client = client.extend({ body: JSON.stringify(body) });
          }
        }
        const response = await client(url);
        if (response.ok) {
          const data = await options.custom.mapResponse(response, params);
          return { data };
        }
        const error = await options.custom.transformError(response, params);
        throw error;
      },
      getApiUrl: () => apiURL
    }
  };
};

// src/data-providers/simple-rest/simple-rest.options.ts
var mapOperator = (operator) => {
  switch (operator) {
    case "ne":
    case "gte":
    case "lte":
      return `_${operator}`;
    case "contains":
      return "_like";
    default:
      return "";
  }
};
var simpleRestDataProviderOptions = {
  getList: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildFilters(params) {
      const { filters = [] } = params;
      const queryFilters = {};
      filters.map((filter) => {
        if ("field" in filter) {
          const { field, operator, value } = filter;
          if (field === "q") {
            queryFilters[field] = value;
            return;
          }
          const mappedOperator = mapOperator(operator);
          queryFilters[`${field}${mappedOperator}`] = value;
        }
      });
      return queryFilters;
    },
    async buildPagination(params) {
      const { pagination } = params;
      const { currentPage = 1, pageSize = 10 } = pagination ?? {};
      const _start = (currentPage - 1) * pageSize;
      const _end = currentPage * pageSize;
      return { _start, _end };
    },
    async buildSorters(params) {
      const { sorters = [] } = params;
      if (!sorters.length)
        return {};
      const sort = [];
      const order = [];
      sorters.forEach((item) => {
        sort.push(item.field);
        order.push(item.order);
      });
      const _sort = sort.join(",");
      const _order = order.join(",");
      return {
        _sort,
        _order
      };
    },
    async buildQueryParams(params) {
      const filters = await this.buildFilters(params);
      const sorters = await this.buildSorters(params);
      const pagination = await this.buildPagination(params);
      return { ...filters, ...sorters, ...pagination };
    },
    async mapResponse(response, params) {
      return await response.json();
    },
    async getTotalCount(response, params) {
      const totalCount = response.headers.get("x-total-count") ?? 0;
      return +totalCount;
    }
  },
  getOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildQueryParams(params) {
      return {};
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  getMany: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildQueryParams(params) {
      return { ids: params.ids };
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  create: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildQueryParams(params) {
      return {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  update: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildQueryParams(params) {
      return {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  deleteOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildQueryParams(params) {
      return {};
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  custom: {
    async buildQueryParams(params) {
      return params.query;
    },
    async buildBodyParams(params) {
      return params.payload ?? {};
    },
    async buildHeaders(params) {
      return params.headers ?? {};
    },
    async mapResponse(response, params) {
      return await response.json();
    }
  },
  getAuthHeader: async () => {
    return {
      headerName: "Authorization",
      headerValue: `Bearer ${localStorage.getItem("token")}`
    };
  },
  refreshToken: {
    getEndpoint: (apiURL) => "/refresh-token",
    async persistTokens(mapResponseResult) {
      localStorage.setItem("token", mapResponseResult.token);
      localStorage.setItem("refreshToken", mapResponseResult.refreshToken);
    },
    async mapResponse(response) {
      return await response.json();
    }
  }
};

// src/data-providers/simple-rest/index.ts
var createSimpleRestDataProvider = (params) => {
  const { apiURL, kyOptions } = params;
  return createDataProvider(apiURL, simpleRestDataProviderOptions, kyOptions);
};
//# sourceMappingURL=simple-rest.cjs.map