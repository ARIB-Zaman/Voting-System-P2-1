"use client"
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useForm: () => useForm,
  useModalForm: () => useModalForm,
  useStepsForm: () => useStepsForm
});
module.exports = __toCommonJS(src_exports);

// src/useForm/index.ts
var import_react = __toESM(require("react"));
var import_get = __toESM(require("lodash/get"));
var import_has = __toESM(require("lodash/has"));
var import_react_hook_form = require("react-hook-form");
var import_core = require("@refinedev/core");
var useForm = /* @__PURE__ */ __name(({
  refineCoreProps,
  warnWhenUnsavedChanges: warnWhenUnsavedChangesProp,
  disableServerSideValidation: disableServerSideValidationProp = false,
  ...rest
} = {}) => {
  const { options } = (0, import_core.useRefineContext)();
  const disableServerSideValidation = (options == null ? void 0 : options.disableServerSideValidation) || disableServerSideValidationProp;
  const translate = (0, import_core.useTranslate)();
  const { warnWhenUnsavedChanges: warnWhenUnsavedChangesRefine, setWarnWhen } = (0, import_core.useWarnAboutChange)();
  const warnWhenUnsavedChanges = warnWhenUnsavedChangesProp ?? warnWhenUnsavedChangesRefine;
  const useHookFormResult = (0, import_react_hook_form.useForm)({
    ...rest
  });
  const {
    control,
    watch,
    setValue,
    getValues,
    handleSubmit: handleSubmitReactHookForm,
    setError,
    formState: { dirtyFields }
  } = useHookFormResult;
  const queryDataRef = import_react.default.useRef(void 0);
  const syncedFieldsRef = import_react.default.useRef(/* @__PURE__ */ new Set());
  const mountedFieldsRef = import_react.default.useRef(/* @__PURE__ */ new Set());
  const useFormCoreResult = (0, import_core.useForm)({
    ...refineCoreProps,
    onMutationError: (error, _variables, _context) => {
      var _a, _b;
      if (disableServerSideValidation) {
        (_a = refineCoreProps == null ? void 0 : refineCoreProps.onMutationError) == null ? void 0 : _a.call(refineCoreProps, error, _variables, _context);
        return;
      }
      const errors = error == null ? void 0 : error.errors;
      for (const key in errors) {
        const isKeyInVariables = Object.keys(
          (0, import_core.flattenObjectKeys)(_variables)
        ).includes(key);
        if (!isKeyInVariables) {
          continue;
        }
        const fieldError = errors[key];
        let newError = "";
        if (Array.isArray(fieldError)) {
          newError = fieldError.join(" ");
        }
        if (typeof fieldError === "string") {
          newError = fieldError;
        }
        if (typeof fieldError === "boolean" && fieldError) {
          newError = "Field is not valid.";
        }
        if (typeof fieldError === "object" && "key" in fieldError) {
          const translatedMessage = translate(
            fieldError.key,
            fieldError.message
          );
          newError = translatedMessage;
        }
        setError(key, {
          message: newError
        });
      }
      (_b = refineCoreProps == null ? void 0 : refineCoreProps.onMutationError) == null ? void 0 : _b.call(refineCoreProps, error, _variables, _context);
    }
  });
  const { query, onFinish, formLoading, onFinishAutoSave } = useFormCoreResult;
  const getMountedFields = /* @__PURE__ */ __name(() => {
    var _a;
    const mounted = ((_a = control._names) == null ? void 0 : _a.mount) ?? /* @__PURE__ */ new Set();
    return new Set(mounted);
  }, "getMountedFields");
  const getRegisteredFields = /* @__PURE__ */ __name(() => {
    const registeredFields = /* @__PURE__ */ new Set();
    const mounted = getMountedFields();
    mounted.forEach((name) => registeredFields.add(name));
    const values = getValues();
    Object.keys((0, import_core.flattenObjectKeys)(values)).forEach((path) => {
      registeredFields.add(path);
    });
    return registeredFields;
  }, "getRegisteredFields");
  const applyValuesToFields = /* @__PURE__ */ __name((fieldNames, data, respectDirty = false) => {
    fieldNames.forEach((path) => {
      if (syncedFieldsRef.current.has(path)) {
        return;
      }
      if (respectDirty && (0, import_get.default)(dirtyFields, path)) {
        syncedFieldsRef.current.add(path);
        return;
      }
      syncedFieldsRef.current.add(path);
      if ((0, import_has.default)(data, path)) {
        setValue(path, (0, import_get.default)(data, path));
      }
    });
  }, "applyValuesToFields");
  (0, import_react.useEffect)(() => {
    var _a;
    const data = (_a = query == null ? void 0 : query.data) == null ? void 0 : _a.data;
    if (!data) {
      queryDataRef.current = void 0;
      syncedFieldsRef.current = /* @__PURE__ */ new Set();
      mountedFieldsRef.current = /* @__PURE__ */ new Set();
      return;
    }
    let isActive = true;
    const applyQueryValues = /* @__PURE__ */ __name(() => {
      if (!isActive)
        return;
      applyValuesToFields(getRegisteredFields(), data, false);
    }, "applyQueryValues");
    queryDataRef.current = data;
    syncedFieldsRef.current = /* @__PURE__ */ new Set();
    mountedFieldsRef.current = getMountedFields();
    if (typeof queueMicrotask === "function") {
      queueMicrotask(applyQueryValues);
    } else {
      Promise.resolve().then(applyQueryValues);
    }
    return () => {
      isActive = false;
    };
  }, [query == null ? void 0 : query.data, setValue, getValues]);
  (0, import_react.useEffect)(() => {
    const subscription = watch((values, { type }) => {
      if (type === "change") {
        onValuesChange(values);
      }
    });
    return () => subscription.unsubscribe();
  }, [watch]);
  (0, import_react.useEffect)(() => {
    const data = queryDataRef.current;
    if (!data) {
      return;
    }
    const mountedFieldNames = getMountedFields();
    if (!mountedFieldNames.size) {
      return;
    }
    let hasNewField = false;
    mountedFieldNames.forEach((name) => {
      if (!mountedFieldsRef.current.has(name)) {
        hasNewField = true;
      }
    });
    if (!hasNewField) {
      return;
    }
    mountedFieldsRef.current = new Set(mountedFieldNames);
    applyValuesToFields(mountedFieldNames, data, true);
  });
  const onValuesChange = /* @__PURE__ */ __name((changeValues) => {
    var _a, _b;
    if (warnWhenUnsavedChanges) {
      setWarnWhen(true);
    }
    if ((_a = refineCoreProps == null ? void 0 : refineCoreProps.autoSave) == null ? void 0 : _a.enabled) {
      setWarnWhen(false);
      const onFinishProps = ((_b = refineCoreProps.autoSave) == null ? void 0 : _b.onFinish) ?? ((values) => values);
      return onFinishAutoSave(onFinishProps(changeValues)).catch(
        (error) => error
      );
    }
    return changeValues;
  }, "onValuesChange");
  const handleSubmit = /* @__PURE__ */ __name((onValid, onInvalid) => async (e) => {
    setWarnWhen(false);
    return handleSubmitReactHookForm(onValid, onInvalid)(e);
  }, "handleSubmit");
  const saveButtonProps = {
    disabled: formLoading,
    onClick: (e) => {
      handleSubmit(
        (v) => onFinish(v).catch(() => {
        }),
        () => false
      )(e);
    }
  };
  return {
    ...useHookFormResult,
    handleSubmit,
    refineCore: useFormCoreResult,
    saveButtonProps
  };
}, "useForm");

// src/useStepsForm/index.ts
var import_react2 = require("react");
var import_get2 = __toESM(require("lodash/get"));
var useStepsForm = /* @__PURE__ */ __name(({
  stepsProps,
  ...rest
} = {}) => {
  const { defaultStep = 0, isBackValidate = false } = stepsProps ?? {};
  const [current, setCurrent] = (0, import_react2.useState)(defaultStep);
  const useHookFormResult = useForm({
    ...rest
  });
  const {
    trigger,
    getValues,
    setValue,
    formState: { dirtyFields },
    refineCore: { query }
  } = useHookFormResult;
  (0, import_react2.useEffect)(() => {
    var _a;
    const data = (_a = query == null ? void 0 : query.data) == null ? void 0 : _a.data;
    if (!data)
      return;
    const registeredFields = Object.keys(getValues());
    Object.entries(data).forEach(([key, value]) => {
      const name = key;
      if (registeredFields.includes(name)) {
        if (!(0, import_get2.default)(dirtyFields, name)) {
          setValue(name, value);
        }
      }
    });
  }, [query == null ? void 0 : query.data, current, setValue, getValues]);
  const go = /* @__PURE__ */ __name((step) => {
    let targetStep = step;
    if (step < 0) {
      targetStep = 0;
    }
    setCurrent(targetStep);
  }, "go");
  const gotoStep = /* @__PURE__ */ __name(async (step) => {
    if (step === current) {
      return;
    }
    if (step < current && !isBackValidate) {
      go(step);
      return;
    }
    const isValid = await trigger();
    if (isValid) {
      go(step);
    }
  }, "gotoStep");
  return {
    ...useHookFormResult,
    steps: {
      currentStep: current,
      gotoStep
    }
  };
}, "useStepsForm");

// src/useModalForm/index.ts
var import_react3 = require("react");
var import_core2 = require("@refinedev/core");
var import_react4 = __toESM(require("react"));
var useModalForm = /* @__PURE__ */ __name(({
  modalProps,
  refineCoreProps,
  syncWithLocation,
  ...rest
} = {}) => {
  var _a, _b;
  const invalidate = (0, import_core2.useInvalidate)();
  const [initiallySynced, setInitiallySynced] = import_react4.default.useState(false);
  const translate = (0, import_core2.useTranslate)();
  const { resource: resourceProp, action: actionProp } = refineCoreProps ?? {};
  const { resource, identifier } = (0, import_core2.useResourceParams)({
    resource: resourceProp
  });
  const { action: actionFromParams } = (0, import_core2.useResourceParams)({
    resource: resourceProp,
    action: actionProp
  });
  const parsed = (0, import_core2.useParsed)();
  const go = (0, import_core2.useGo)();
  const getUserFriendlyName = (0, import_core2.useUserFriendlyName)();
  const action = actionProp ?? actionFromParams ?? "";
  const syncingId = !(typeof syncWithLocation === "object" && (syncWithLocation == null ? void 0 : syncWithLocation.syncId) === false);
  const syncWithLocationKey = typeof syncWithLocation === "object" && "key" in syncWithLocation ? syncWithLocation.key : resource && action && syncWithLocation ? `modal-${identifier}-${action}` : void 0;
  const {
    defaultVisible = false,
    autoSubmitClose = true,
    autoResetForm = true,
    autoResetFormWhenClose = true
  } = modalProps ?? {};
  const useHookFormResult = useForm({
    refineCoreProps: {
      ...refineCoreProps,
      meta: {
        ...syncWithLocationKey ? { [syncWithLocationKey]: void 0 } : {},
        ...refineCoreProps == null ? void 0 : refineCoreProps.meta
      }
    },
    ...rest
  });
  const {
    reset,
    refineCore: { onFinish, id, setId, autoSaveProps, query },
    saveButtonProps,
    handleSubmit
  } = useHookFormResult;
  const { visible, show, close } = (0, import_core2.useModal)({
    defaultVisible
  });
  import_react4.default.useEffect(() => {
    var _a2;
    if (!visible || !((_a2 = query == null ? void 0 : query.data) == null ? void 0 : _a2.data))
      return;
    const formData = query.data.data;
    if (!formData)
      return;
    reset(formData, {
      ...!autoResetFormWhenClose && {
        keepDirtyValues: true
      }
    });
  }, [visible, (_a = query == null ? void 0 : query.data) == null ? void 0 : _a.data, autoResetFormWhenClose]);
  import_react4.default.useEffect(() => {
    var _a2, _b2, _c, _d;
    if (initiallySynced === false && syncWithLocationKey) {
      const openStatus = (_b2 = (_a2 = parsed == null ? void 0 : parsed.params) == null ? void 0 : _a2[syncWithLocationKey]) == null ? void 0 : _b2.open;
      if (typeof openStatus === "boolean") {
        if (openStatus) {
          show();
        }
      } else if (typeof openStatus === "string") {
        if (openStatus === "true") {
          show();
        }
      }
      if (syncingId) {
        const idFromParams = (_d = (_c = parsed == null ? void 0 : parsed.params) == null ? void 0 : _c[syncWithLocationKey]) == null ? void 0 : _d.id;
        if (idFromParams) {
          setId == null ? void 0 : setId(idFromParams);
        }
      }
      setInitiallySynced(true);
    }
  }, [syncWithLocationKey, parsed, syncingId, setId]);
  import_react4.default.useEffect(() => {
    var _a2;
    if (initiallySynced === true) {
      if (visible && syncWithLocationKey) {
        go({
          query: {
            [syncWithLocationKey]: {
              ...(_a2 = parsed == null ? void 0 : parsed.params) == null ? void 0 : _a2[syncWithLocationKey],
              open: true,
              ...syncingId && id && { id }
            }
          },
          options: { keepQuery: true },
          type: "replace"
        });
      } else if (syncWithLocationKey && !visible) {
        go({
          query: {
            [syncWithLocationKey]: void 0
          },
          options: { keepQuery: true },
          type: "replace"
        });
      }
    }
  }, [id, visible, show, syncWithLocationKey, syncingId]);
  const submit = /* @__PURE__ */ __name(async (values) => {
    await onFinish(values);
    if (autoSubmitClose) {
      close();
    }
    if (autoResetForm) {
      reset();
    }
  }, "submit");
  const { warnWhen, setWarnWhen } = (0, import_core2.useWarnAboutChange)();
  const handleClose = (0, import_react3.useCallback)(() => {
    var _a2;
    if (autoSaveProps.status === "success" && ((_a2 = refineCoreProps == null ? void 0 : refineCoreProps.autoSave) == null ? void 0 : _a2.invalidateOnClose)) {
      invalidate({
        id,
        invalidates: refineCoreProps.invalidates || ["list", "many", "detail"],
        dataProviderName: refineCoreProps.dataProviderName,
        resource: identifier
      });
    }
    if (warnWhen) {
      const warnWhenConfirm = window.confirm(
        translate(
          "warnWhenUnsavedChanges",
          "Are you sure you want to leave? You have unsaved changes."
        )
      );
      if (warnWhenConfirm) {
        setWarnWhen(false);
      } else {
        return;
      }
    }
    setId == null ? void 0 : setId(void 0);
    close();
    if (autoResetFormWhenClose) {
      reset();
    }
  }, [warnWhen, autoSaveProps.status]);
  const handleShow = (0, import_react3.useCallback)(
    (showId) => {
      if (typeof showId !== "undefined") {
        setId == null ? void 0 : setId(showId);
      }
      const needsIdToOpen = action === "edit" || action === "clone";
      const hasId = typeof showId !== "undefined" || typeof id !== "undefined";
      if (needsIdToOpen ? hasId : true) {
        show();
      }
    },
    [id, action, setId, show]
  );
  const title = translate(
    `${identifier}.titles.${actionProp}`,
    void 0,
    `${getUserFriendlyName(
      `${actionProp} ${((_b = resource == null ? void 0 : resource.meta) == null ? void 0 : _b.label) ?? identifier}`,
      "singular"
    )}`
  );
  return {
    modal: {
      submit,
      close: handleClose,
      show: handleShow,
      visible,
      title
    },
    ...useHookFormResult,
    saveButtonProps: {
      ...saveButtonProps,
      onClick: (e) => handleSubmit(submit)(e)
    }
  };
}, "useModalForm");
//# sourceMappingURL=index.cjs.map