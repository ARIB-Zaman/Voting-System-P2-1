var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/data-providers/nestjsx-crud/index.ts
var nestjsx_crud_exports = {};
__export(nestjsx_crud_exports, {
  createNestjsxCrudDataProvider: () => createNestjsxCrudDataProvider
});
module.exports = __toCommonJS(nestjsx_crud_exports);

// src/create-data-provider.ts
var import_deepmerge = __toESM(require("deepmerge"));
var import_ky = __toESM(require("ky"));
var import_qs = __toESM(require("qs"));

// src/default.options.ts
var defaultCreateDataProviderOptions = {
  getList: {
    getEndpoint(params) {
      return `${params.resource}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      const { filters, sorters, pagination } = params;
      const queryParams = {
        filters,
        sorters,
        pagination,
        ...(_a = params.meta) == null ? void 0 : _a.query
      };
      return queryParams;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async getTotalCount(_response, _params) {
      return -1;
    }
  },
  getOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    }
  },
  create: {
    getEndpoint(params) {
      return params.resource;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({ ...body, variables: params.variables }),
        statusCode: response.status
      };
    }
  },
  update: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    getRequestMethod(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.method) ?? "patch";
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async buildBodyParams(params) {
      return params.variables;
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id,
          variables: params.variables
        }),
        statusCode: response.status
      };
    }
  },
  deleteOne: {
    getEndpoint(params) {
      return `${params.resource}/${params.id}`;
    },
    async buildHeaders(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    async buildQueryParams(params) {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.query) ?? {};
    },
    async mapResponse(_response, _params) {
      return void 0;
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          id: params.id
        }),
        statusCode: response.status
      };
    }
  },
  custom: {
    async buildQueryParams(params) {
      return params.query ?? {};
    },
    async buildHeaders(params) {
      return params.headers ?? {};
    },
    async buildBodyParams(params) {
      return params.payload ?? {};
    },
    async mapResponse(response, _params) {
      return await response.json();
    },
    async transformError(response, params) {
      const body = await response.json();
      return {
        message: JSON.stringify({
          ...body,
          params
        }),
        statusCode: response.status
      };
    }
  }
};

// src/create-data-provider.ts
var createDataProvider = (apiURL, baseOptions = defaultCreateDataProviderOptions, kyOptions = {}) => {
  const options = (0, import_deepmerge.default)(defaultCreateDataProviderOptions, baseOptions);
  const ky = import_ky.default.create({
    prefixUrl: apiURL,
    ...kyOptions,
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...kyOptions.headers
    },
    throwHttpErrors: false
  });
  return {
    kyInstance: ky,
    dataProvider: {
      getList: async (params) => {
        const endpoint = options.getList.getEndpoint(params);
        const headers = await options.getList.buildHeaders(params);
        const query = await options.getList.buildQueryParams(params);
        const response = await ky(endpoint, {
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getList.mapResponse(
          response.clone(),
          params
        );
        const total = await options.getList.getTotalCount(
          response.clone(),
          params
        );
        return { data, total };
      },
      getOne: async (params) => {
        const endpoint = options.getOne.getEndpoint(params);
        const headers = await options.getOne.buildHeaders(params);
        const query = await options.getOne.buildQueryParams(params);
        const response = await ky(endpoint, {
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        const data = await options.getOne.mapResponse(response, params);
        return { data };
      },
      getMany: options.getMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.getMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.getMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.getMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky(endpoint, {
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.getMany.mapResponse(response, params);
          return { data };
        }
        let error;
        if (options.getMany.transformError) {
          error = await options.getMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      create: async (params) => {
        const endpoint = options.create.getEndpoint(params);
        const headers = await options.create.buildHeaders(params);
        const query = await options.create.buildQueryParams(params);
        const body = await options.create.buildBodyParams(params);
        const response = await ky(endpoint, {
          method: "post",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.create.mapResponse(response, params);
          return { data };
        }
        const error = await options.create.transformError(response, params);
        throw error;
      },
      createMany: options.createMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const endpoint = ((_b = (_a = options.createMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.createMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.createMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.createMany.buildBodyParams(params);
        const response = await ky(endpoint, {
          method: "post",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.createMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.createMany.transformError) {
          error = await ((_g = options.createMany) == null ? void 0 : _g.transformError(
            response,
            params
          ));
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      update: async (params) => {
        const endpoint = options.update.getEndpoint(params);
        const method = options.update.getRequestMethod(params);
        const headers = await options.update.buildHeaders(params);
        const query = await options.update.buildQueryParams(params);
        const body = await options.update.buildBodyParams(params);
        const response = await ky(endpoint, {
          method,
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.update.mapResponse(response, params);
          return { data };
        }
        const error = await options.update.transformError(response, params);
        throw error;
      },
      updateMany: options.updateMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = options.updateMany.getEndpoint(params);
        const method = ((_b = (_a = options.updateMany).getRequestMethod) == null ? void 0 : _b.call(_a, params)) ?? "patch";
        const headers = await ((_d = (_c = options.updateMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.updateMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const body = await options.updateMany.buildBodyParams(params);
        const response = await ky(endpoint, {
          method,
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true }),
          body: JSON.stringify(body)
        });
        if (response.ok) {
          const data = await options.updateMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        let error;
        if (options.updateMany.transformError) {
          error = await options.updateMany.transformError(response, params);
        } else {
          error = await response.json();
        }
        throw error;
      } : void 0,
      deleteOne: async (params) => {
        const endpoint = options.deleteOne.getEndpoint(params);
        const headers = await options.deleteOne.buildHeaders(params);
        const query = await options.deleteOne.buildQueryParams(params);
        const response = await ky(endpoint, {
          method: "delete",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        if (response.ok) {
          const data = await options.deleteOne.mapResponse(response, params);
          return { data };
        }
        const error = await options.deleteOne.transformError(response, params);
        throw error;
      },
      deleteMany: options.deleteMany ? async (params) => {
        var _a, _b, _c, _d, _e, _f;
        const endpoint = ((_b = (_a = options.deleteMany).getEndpoint) == null ? void 0 : _b.call(_a, params)) ?? params.resource;
        const headers = await ((_d = (_c = options.deleteMany).buildHeaders) == null ? void 0 : _d.call(_c, params)) ?? {};
        const query = await ((_f = (_e = options.deleteMany).buildQueryParams) == null ? void 0 : _f.call(_e, params)) ?? {};
        const response = await ky(endpoint, {
          method: "delete",
          headers,
          searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
        });
        if (options.deleteMany.mapResponse) {
          const data = await options.deleteMany.mapResponse(
            response,
            params
          );
          return { data };
        }
        return { data: void 0 };
      } : void 0,
      custom: async (params) => {
        const { method, url } = params;
        let client = import_ky.default.create({
          method,
          ...kyOptions
        });
        const headers = await options.custom.buildHeaders(params);
        if (headers) {
          client = client.extend({ headers });
        }
        const query = await options.custom.buildQueryParams(params);
        if (query) {
          client = client.extend({
            searchParams: import_qs.default.stringify(query, { encodeValuesOnly: true })
          });
        }
        if (["post", "put", "patch"].includes(method)) {
          const body = await options.custom.buildBodyParams(params);
          if (body) {
            client = client.extend({ body: JSON.stringify(body) });
          }
        }
        const response = await client(url);
        if (response.ok) {
          const data = await options.custom.mapResponse(response, params);
          return { data };
        }
        const error = await options.custom.transformError(response, params);
        throw error;
      },
      getApiUrl: () => apiURL
    }
  };
};

// src/data-providers/nestjsx-crud/nestjsx-crud.options.ts
var import_crud_request2 = require("@nestjsx/crud-request");

// src/data-providers/nestjsx-crud/utils/mapOperator.ts
var import_crud_request = require("@nestjsx/crud-request");
var mapOperator = (operator) => {
  switch (operator) {
    case "and":
      return "$and";
    case "or":
      return "$or";
    case "eq":
      return import_crud_request.CondOperator.EQUALS;
    case "ne":
      return import_crud_request.CondOperator.NOT_EQUALS;
    case "lt":
      return import_crud_request.CondOperator.LOWER_THAN;
    case "gt":
      return import_crud_request.CondOperator.GREATER_THAN;
    case "lte":
      return import_crud_request.CondOperator.LOWER_THAN_EQUALS;
    case "gte":
      return import_crud_request.CondOperator.GREATER_THAN_EQUALS;
    case "in":
      return import_crud_request.CondOperator.IN;
    case "nin":
      return import_crud_request.CondOperator.NOT_IN;
    case "contains":
      return import_crud_request.CondOperator.CONTAINS_LOW;
    case "ncontains":
      return import_crud_request.CondOperator.EXCLUDES_LOW;
    case "containss":
      return import_crud_request.CondOperator.CONTAINS;
    case "ncontainss":
      return import_crud_request.CondOperator.EXCLUDES;
    case "null":
      return import_crud_request.CondOperator.IS_NULL;
    case "nnull":
      return import_crud_request.CondOperator.NOT_NULL;
    case "startswith":
      return import_crud_request.CondOperator.STARTS_LOW;
    case "startswiths":
      return import_crud_request.CondOperator.STARTS;
    case "endswith":
      return import_crud_request.CondOperator.ENDS_LOW;
    case "endswiths":
      return import_crud_request.CondOperator.ENDS;
    case "between":
      return import_crud_request.CondOperator.BETWEEN;
  }
  return import_crud_request.CondOperator.EQUALS;
};

// src/data-providers/nestjsx-crud/utils/handleFilter.ts
var generateSearchFilter = (filters) => {
  return createSearchQuery({
    operator: "and",
    value: filters
  });
};
var createSearchQuery = (filter) => {
  if (filter.operator !== "and" && filter.operator !== "or" && "field" in filter) {
    return {
      [filter.field]: {
        [mapOperator(filter.operator)]: filter.value
      }
    };
  }
  const { operator } = filter;
  return {
    [mapOperator(operator)]: filter.value.map(
      (filter2) => createSearchQuery(filter2)
    )
  };
};
var handleFilter = (query, filters) => {
  if (Array.isArray(filters) && filters.length > 0) {
    query.search(generateSearchFilter(filters));
  }
  return query;
};

// src/data-providers/nestjsx-crud/utils/handleJoin.ts
var handleJoin = (query, join) => {
  if (join) {
    query.setJoin(join);
  }
  return query;
};

// src/data-providers/nestjsx-crud/utils/handlePagination.ts
var handlePagination = (query, pagination) => {
  const { currentPage = 1, pageSize = 10, mode = "server" } = pagination ?? {};
  if (mode === "server") {
    query.setLimit(pageSize).setPage(currentPage).setOffset((currentPage - 1) * pageSize);
  }
  return query;
};

// src/data-providers/nestjsx-crud/utils/handleSort.ts
var generateSort = (sort) => {
  if (sort && sort.length > 0) {
    const multipleSort = [];
    sort.map(({ field, order }) => {
      if (field && order) {
        multipleSort.push({
          field,
          order: order.toUpperCase()
        });
      }
    });
    return multipleSort;
  }
  return;
};
var handleSort = (query, sorters) => {
  const sortBy = generateSort(sorters);
  if (sortBy) {
    query.sortBy(sortBy);
  }
  return query;
};

// src/data-providers/nestjsx-crud/utils/transformErrorMessages.ts
var transformErrorMessages = (errorMessages) => {
  const transformedErrors = {};
  for (const errorMessage of errorMessages) {
    const separatorIndex = errorMessage.indexOf(" ");
    const field = errorMessage.substring(0, separatorIndex);
    if (transformedErrors[field]) {
      transformedErrors[field].push(errorMessage);
    } else {
      transformedErrors[field] = [errorMessage];
    }
  }
  return transformedErrors;
};

// src/data-providers/nestjsx-crud/utils/transformHttpError.ts
var transformHttpError = (error) => {
  const message = error.error;
  const statusCode = error.statusCode;
  const errorMessages = error.message;
  const errors = transformErrorMessages(errorMessages);
  const httpError = {
    statusCode,
    message,
    errors
  };
  return httpError;
};

// src/data-providers/nestjsx-crud/nestjsx-crud.options.ts
var nestjsxCrudDataProviderOptions = {
  getList: {
    getEndpoint: (params) => params.resource,
    buildQueryParams: async (params) => {
      var _a;
      let query = import_crud_request2.RequestQueryBuilder.create();
      query = handleFilter(query, params.filters);
      query = handleJoin(query, (_a = params.meta) == null ? void 0 : _a.join);
      query = handlePagination(query, params.pagination);
      query = handleSort(query, params.sorters);
      return query.queryObject;
    },
    mapResponse: async (response, params) => {
      const body = await response.json();
      if (Array.isArray(body)) {
        return body;
      }
      return body.data;
    },
    getTotalCount: async (response, params) => {
      const body = await response.json();
      if (Array.isArray(body)) {
        return body.length;
      }
      return body.total;
    }
  },
  getMany: {
    getEndpoint: (params) => params.resource,
    buildQueryParams: async ({ ids, meta }) => {
      let query = import_crud_request2.RequestQueryBuilder.create().setFilter({
        field: "id",
        operator: import_crud_request2.CondOperator.IN,
        value: ids
      });
      query = handleJoin(query, meta == null ? void 0 : meta.join);
      return query.queryObject;
    },
    mapResponse: async (response, params) => {
      const body = await response.json();
      if (Array.isArray(body)) {
        return body;
      }
      return body.data;
    }
  },
  create: {
    getEndpoint: (params) => params.resource,
    buildBodyParams: ({ variables }) => variables,
    mapResponse: async (response) => await response.json(),
    transformError: async (response, _params) => {
      const error = await response.json();
      return transformHttpError(error);
    }
  },
  update: {
    getEndpoint: ({ resource, id }) => `${resource}/${id}`,
    buildBodyParams: ({ variables }) => variables,
    mapResponse: async (response) => await response.json(),
    transformError: async (response, _params) => {
      const error = await response.json();
      return transformHttpError(error);
    }
  },
  getOne: {
    getEndpoint: ({ resource, id }) => `${resource}/${id}`,
    buildQueryParams: async ({ meta }) => {
      let query = import_crud_request2.RequestQueryBuilder.create();
      query = handleJoin(query, meta == null ? void 0 : meta.join);
      return query.queryObject;
    },
    mapResponse: async (response, _params) => await response.json()
  },
  deleteOne: {
    getEndpoint: ({ resource, id }) => `${resource}/${id}`,
    mapResponse: async (_response, _params) => void 0
  },
  custom: {
    buildQueryParams: async (params) => {
      var _a;
      let query = import_crud_request2.RequestQueryBuilder.create();
      query = handleFilter(query, params.filters);
      query = handleJoin(query, (_a = params.meta) == null ? void 0 : _a.join);
      query = handleSort(query, params.sorters);
      return query.queryObject;
    },
    buildHeaders: async (params) => {
      var _a;
      return ((_a = params.meta) == null ? void 0 : _a.headers) ?? {};
    },
    buildBodyParams: async (params) => {
      return params.payload ?? {};
    },
    mapResponse: async (response, _params) => {
      return await response.json();
    }
  }
};

// src/data-providers/nestjsx-crud/index.ts
var createNestjsxCrudDataProvider = (params) => {
  const { apiURL, kyOptions } = params;
  return createDataProvider(apiURL, nestjsxCrudDataProviderOptions, kyOptions);
};
//# sourceMappingURL=nestjsx-crud.cjs.map