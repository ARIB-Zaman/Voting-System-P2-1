"use client"
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useTable: () => useTable
});
module.exports = __toCommonJS(src_exports);

// src/useTable/index.ts
var import_react2 = require("react");
var import_isEqual = __toESM(require("lodash/isEqual"));
var import_core = require("@refinedev/core");
var import_react_table = require("@tanstack/react-table");

// src/utils/useIsFirstRender/index.ts
var import_react = require("react");
var useIsFirstRender = /* @__PURE__ */ __name(() => {
  const firstRender = (0, import_react.useRef)(true);
  (0, import_react.useEffect)(() => {
    firstRender.current = false;
  }, []);
  return firstRender.current;
}, "useIsFirstRender");

// src/utils/column-filters-to-crud-filters/index.ts
var columnFiltersToCrudFilters = /* @__PURE__ */ __name(({
  columns,
  columnFilters
}) => {
  return (columnFilters == null ? void 0 : columnFilters.map((filter) => {
    var _a, _b, _c, _d;
    const operator = filter.operator ?? ((_b = (_a = columns.find((col) => col.id === filter.id)) == null ? void 0 : _a.meta) == null ? void 0 : _b.filterOperator);
    const isConditional = operator === "and" || operator === "or";
    if (isConditional && Array.isArray(filter.value)) {
      const filterKey = ((_d = (_c = columns.find((c) => c.id === filter.id)) == null ? void 0 : _c.meta) == null ? void 0 : _d.filterKey) ?? filter.id;
      return {
        key: filterKey,
        operator,
        value: filter.value
      };
    }
    const defaultOperator = Array.isArray(filter.value) ? "in" : "eq";
    return {
      field: filter.id,
      operator: operator ?? defaultOperator,
      value: filter.value
    };
  })) ?? [];
}, "columnFiltersToCrudFilters");

// src/utils/get-removed-filters/index.ts
var getRemovedFilters = /* @__PURE__ */ __name(({
  nextFilters,
  coreFilters
}) => {
  const removedFilters = coreFilters.filter(
    (filter) => !nextFilters.some((nextFilter) => {
      const isFilterConditional = filter.operator === "and" || filter.operator === "or";
      const isCrudFilterConditional = nextFilter.operator === "and" || nextFilter.operator === "or";
      const hasSameOperator = filter.operator === nextFilter.operator;
      const hasSameKey = isFilterConditional && isCrudFilterConditional && filter.key === nextFilter.key;
      const hasSameField = !isFilterConditional && !isCrudFilterConditional && filter.field === nextFilter.field;
      return hasSameOperator && (hasSameKey || hasSameField);
    })
  );
  return removedFilters.map((filter) => {
    if (filter.operator === "and" || filter.operator === "or") {
      return {
        key: filter.key,
        operator: filter.operator,
        value: []
      };
    }
    return {
      field: filter.field,
      operator: filter.operator,
      value: void 0
    };
  });
}, "getRemovedFilters");

// src/utils/crud-filters-to-column-filters/index.ts
var crudFiltersToColumnFilters = /* @__PURE__ */ __name(({
  columns,
  crudFilters
}) => {
  return crudFilters.map((filter) => {
    var _a;
    if (filter.operator === "and" || filter.operator === "or") {
      if (filter.key) {
        const filterId = ((_a = columns.find(
          (col) => {
            var _a2;
            return ((_a2 = col.meta) == null ? void 0 : _a2.filterKey) === filter.key;
          }
        )) == null ? void 0 : _a.id) ?? filter.key;
        return {
          id: filterId,
          operator: filter.operator,
          value: filter.value
        };
      }
      return void 0;
    }
    return {
      id: filter.field,
      operator: filter.operator,
      value: filter.value
    };
  }).filter(Boolean);
}, "crudFiltersToColumnFilters");

// src/useTable/index.ts
function useTable({
  refineCoreProps = {},
  initialState: reactTableInitialState = {},
  ...rest
}) {
  var _a, _b, _c;
  const isFirstRender = useIsFirstRender();
  const useTableResult = (0, import_core.useTable)(
    refineCoreProps
  );
  const isServerSideFilteringEnabled = (((_a = refineCoreProps.filters) == null ? void 0 : _a.mode) || "server") === "server";
  const isServerSideSortingEnabled = (((_b = refineCoreProps.sorters) == null ? void 0 : _b.mode) || "server") === "server";
  const isPaginationEnabled = ((_c = refineCoreProps.pagination) == null ? void 0 : _c.mode) !== "off";
  const {
    tableQuery: { data },
    currentPage,
    setCurrentPage,
    pageSize: pageSizeCore,
    setPageSize: setPageSizeCore,
    sorters,
    setSorters,
    filters: filtersCore,
    setFilters,
    pageCount
  } = useTableResult;
  const reactTableResult = (0, import_react_table.useReactTable)({
    data: (data == null ? void 0 : data.data) ?? [],
    getCoreRowModel: (0, import_react_table.getCoreRowModel)(),
    getSortedRowModel: isServerSideSortingEnabled ? void 0 : (0, import_react_table.getSortedRowModel)(),
    getFilteredRowModel: isServerSideFilteringEnabled ? void 0 : (0, import_react_table.getFilteredRowModel)(),
    initialState: {
      pagination: {
        pageIndex: currentPage - 1,
        pageSize: pageSizeCore
      },
      sorting: sorters.map((sorting2) => ({
        id: sorting2.field,
        desc: sorting2.order === "desc"
      })),
      columnFilters: crudFiltersToColumnFilters({
        columns: rest.columns,
        crudFilters: filtersCore
      }),
      ...reactTableInitialState
    },
    pageCount,
    manualPagination: true,
    manualSorting: isServerSideSortingEnabled,
    manualFiltering: isServerSideFilteringEnabled,
    ...rest
  });
  const { state, columns } = reactTableResult.options;
  const { pagination, sorting, columnFilters } = state;
  const { pageIndex, pageSize } = pagination ?? {};
  (0, import_react2.useEffect)(() => {
    if (pageIndex !== void 0) {
      setCurrentPage(pageIndex + 1);
    }
  }, [pageIndex]);
  (0, import_react2.useEffect)(() => {
    if (pageSize !== void 0) {
      setPageSizeCore(pageSize);
    }
  }, [pageSize]);
  (0, import_react2.useEffect)(() => {
    if (sorting !== void 0) {
      const newSorters = sorting.map((sorting2) => ({
        field: sorting2.id,
        order: sorting2.desc ? "desc" : "asc"
      }));
      if (!(0, import_isEqual.default)(sorters, newSorters)) {
        setSorters(newSorters);
      }
      if (sorting.length > 0 && isPaginationEnabled && !isFirstRender) {
        setCurrentPage(1);
      }
    }
  }, [sorting]);
  (0, import_react2.useEffect)(() => {
    const allColumns = reactTableResult.getAllColumns().map((col) => col.columnDef);
    const crudFilters = columnFiltersToCrudFilters({
      columns: allColumns,
      columnFilters
    });
    crudFilters.push(
      ...getRemovedFilters({
        nextFilters: crudFilters,
        coreFilters: filtersCore
      })
    );
    if (!(0, import_isEqual.default)(crudFilters, filtersCore)) {
      setFilters(crudFilters);
    }
    if (crudFilters.length > 0 && isPaginationEnabled && !isFirstRender) {
      setCurrentPage(1);
    }
  }, [columnFilters, columns]);
  return {
    reactTable: reactTableResult,
    refineCore: useTableResult
  };
}
__name(useTable, "useTable");
//# sourceMappingURL=index.cjs.map