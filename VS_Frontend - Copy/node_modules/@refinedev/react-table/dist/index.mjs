"use client"
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/useTable/index.ts
import { useEffect as useEffect2 } from "react";
import isEqual from "lodash/isEqual";
import {
  useTable as useTableCore
} from "@refinedev/core";
import {
  useReactTable,
  getCoreRowModel,
  getSortedRowModel,
  getFilteredRowModel
} from "@tanstack/react-table";

// src/utils/useIsFirstRender/index.ts
import { useEffect, useRef } from "react";
var useIsFirstRender = /* @__PURE__ */ __name(() => {
  const firstRender = useRef(true);
  useEffect(() => {
    firstRender.current = false;
  }, []);
  return firstRender.current;
}, "useIsFirstRender");

// src/utils/column-filters-to-crud-filters/index.ts
var columnFiltersToCrudFilters = /* @__PURE__ */ __name(({
  columns,
  columnFilters
}) => {
  return (columnFilters == null ? void 0 : columnFilters.map((filter) => {
    var _a, _b, _c, _d;
    const operator = filter.operator ?? ((_b = (_a = columns.find((col) => col.id === filter.id)) == null ? void 0 : _a.meta) == null ? void 0 : _b.filterOperator);
    const isConditional = operator === "and" || operator === "or";
    if (isConditional && Array.isArray(filter.value)) {
      const filterKey = ((_d = (_c = columns.find((c) => c.id === filter.id)) == null ? void 0 : _c.meta) == null ? void 0 : _d.filterKey) ?? filter.id;
      return {
        key: filterKey,
        operator,
        value: filter.value
      };
    }
    const defaultOperator = Array.isArray(filter.value) ? "in" : "eq";
    return {
      field: filter.id,
      operator: operator ?? defaultOperator,
      value: filter.value
    };
  })) ?? [];
}, "columnFiltersToCrudFilters");

// src/utils/get-removed-filters/index.ts
var getRemovedFilters = /* @__PURE__ */ __name(({
  nextFilters,
  coreFilters
}) => {
  const removedFilters = coreFilters.filter(
    (filter) => !nextFilters.some((nextFilter) => {
      const isFilterConditional = filter.operator === "and" || filter.operator === "or";
      const isCrudFilterConditional = nextFilter.operator === "and" || nextFilter.operator === "or";
      const hasSameOperator = filter.operator === nextFilter.operator;
      const hasSameKey = isFilterConditional && isCrudFilterConditional && filter.key === nextFilter.key;
      const hasSameField = !isFilterConditional && !isCrudFilterConditional && filter.field === nextFilter.field;
      return hasSameOperator && (hasSameKey || hasSameField);
    })
  );
  return removedFilters.map((filter) => {
    if (filter.operator === "and" || filter.operator === "or") {
      return {
        key: filter.key,
        operator: filter.operator,
        value: []
      };
    }
    return {
      field: filter.field,
      operator: filter.operator,
      value: void 0
    };
  });
}, "getRemovedFilters");

// src/utils/crud-filters-to-column-filters/index.ts
var crudFiltersToColumnFilters = /* @__PURE__ */ __name(({
  columns,
  crudFilters
}) => {
  return crudFilters.map((filter) => {
    var _a;
    if (filter.operator === "and" || filter.operator === "or") {
      if (filter.key) {
        const filterId = ((_a = columns.find(
          (col) => {
            var _a2;
            return ((_a2 = col.meta) == null ? void 0 : _a2.filterKey) === filter.key;
          }
        )) == null ? void 0 : _a.id) ?? filter.key;
        return {
          id: filterId,
          operator: filter.operator,
          value: filter.value
        };
      }
      return void 0;
    }
    return {
      id: filter.field,
      operator: filter.operator,
      value: filter.value
    };
  }).filter(Boolean);
}, "crudFiltersToColumnFilters");

// src/useTable/index.ts
function useTable({
  refineCoreProps = {},
  initialState: reactTableInitialState = {},
  ...rest
}) {
  var _a, _b, _c;
  const isFirstRender = useIsFirstRender();
  const useTableResult = useTableCore(
    refineCoreProps
  );
  const isServerSideFilteringEnabled = (((_a = refineCoreProps.filters) == null ? void 0 : _a.mode) || "server") === "server";
  const isServerSideSortingEnabled = (((_b = refineCoreProps.sorters) == null ? void 0 : _b.mode) || "server") === "server";
  const isPaginationEnabled = ((_c = refineCoreProps.pagination) == null ? void 0 : _c.mode) !== "off";
  const {
    tableQuery: { data },
    currentPage,
    setCurrentPage,
    pageSize: pageSizeCore,
    setPageSize: setPageSizeCore,
    sorters,
    setSorters,
    filters: filtersCore,
    setFilters,
    pageCount
  } = useTableResult;
  const reactTableResult = useReactTable({
    data: (data == null ? void 0 : data.data) ?? [],
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: isServerSideSortingEnabled ? void 0 : getSortedRowModel(),
    getFilteredRowModel: isServerSideFilteringEnabled ? void 0 : getFilteredRowModel(),
    initialState: {
      pagination: {
        pageIndex: currentPage - 1,
        pageSize: pageSizeCore
      },
      sorting: sorters.map((sorting2) => ({
        id: sorting2.field,
        desc: sorting2.order === "desc"
      })),
      columnFilters: crudFiltersToColumnFilters({
        columns: rest.columns,
        crudFilters: filtersCore
      }),
      ...reactTableInitialState
    },
    pageCount,
    manualPagination: true,
    manualSorting: isServerSideSortingEnabled,
    manualFiltering: isServerSideFilteringEnabled,
    ...rest
  });
  const { state, columns } = reactTableResult.options;
  const { pagination, sorting, columnFilters } = state;
  const { pageIndex, pageSize } = pagination ?? {};
  useEffect2(() => {
    if (pageIndex !== void 0) {
      setCurrentPage(pageIndex + 1);
    }
  }, [pageIndex]);
  useEffect2(() => {
    if (pageSize !== void 0) {
      setPageSizeCore(pageSize);
    }
  }, [pageSize]);
  useEffect2(() => {
    if (sorting !== void 0) {
      const newSorters = sorting.map((sorting2) => ({
        field: sorting2.id,
        order: sorting2.desc ? "desc" : "asc"
      }));
      if (!isEqual(sorters, newSorters)) {
        setSorters(newSorters);
      }
      if (sorting.length > 0 && isPaginationEnabled && !isFirstRender) {
        setCurrentPage(1);
      }
    }
  }, [sorting]);
  useEffect2(() => {
    const allColumns = reactTableResult.getAllColumns().map((col) => col.columnDef);
    const crudFilters = columnFiltersToCrudFilters({
      columns: allColumns,
      columnFilters
    });
    crudFilters.push(
      ...getRemovedFilters({
        nextFilters: crudFilters,
        coreFilters: filtersCore
      })
    );
    if (!isEqual(crudFilters, filtersCore)) {
      setFilters(crudFilters);
    }
    if (crudFilters.length > 0 && isPaginationEnabled && !isFirstRender) {
      setCurrentPage(1);
    }
  }, [columnFilters, columns]);
  return {
    reactTable: reactTableResult,
    refineCore: useTableResult
  };
}
__name(useTable, "useTable");
export {
  useTable
};
//# sourceMappingURL=index.mjs.map