var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  axiosInstance: () => axiosInstance,
  default: () => src_default,
  generateFilter: () => generateFilter,
  generateSort: () => generateSort,
  mapOperator: () => mapOperator,
  stringify: () => import_query_string2.stringify
});
module.exports = __toCommonJS(src_exports);
var import_query_string2 = require("query-string");

// src/provider.ts
var import_query_string = require("query-string");

// src/utils/mapOperator.ts
var mapOperator = (operator) => {
  switch (operator) {
    case "ne":
    case "gte":
    case "lte":
      return `_${operator}`;
    case "contains":
      return "_like";
    default:
      return "";
  }
};

// src/utils/generateSort.ts
var generateSort = (sorters) => {
  if (sorters && sorters.length > 0) {
    const _sort = [];
    const _order = [];
    sorters.map((item) => {
      _sort.push(item.field);
      _order.push(item.order);
    });
    return {
      _sort,
      _order
    };
  }
  return;
};

// src/utils/generateFilter.ts
var generateFilter = (filters) => {
  const queryFilters = {};
  if (filters) {
    filters.map((filter) => {
      if (filter.operator === "or" || filter.operator === "and") {
        throw new Error(
          `[@refinedev/simple-rest]: \`operator: ${filter.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`
        );
      }
      if ("field" in filter) {
        const { field, operator, value } = filter;
        if (field === "q") {
          queryFilters[field] = value;
          return;
        }
        const mappedOperator = mapOperator(operator);
        queryFilters[`${field}${mappedOperator}`] = value;
      }
    });
  }
  return queryFilters;
};

// src/utils/axios.ts
var import_axios = __toESM(require("axios"));
var axiosInstance = import_axios.default.create();
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    var _a, _b, _c;
    const customError = {
      ...error,
      message: (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message,
      statusCode: (_c = error.response) == null ? void 0 : _c.status
    };
    return Promise.reject(customError);
  }
);

// src/provider.ts
var dataProvider = (apiUrl, httpClient = axiosInstance) => ({
  getList: async ({ resource, pagination, filters, sorters, meta }) => {
    const url = `${apiUrl}/${resource}`;
    const {
      currentPage = 1,
      pageSize = 10,
      mode = "server"
    } = pagination ?? {};
    const { headers: headersFromMeta, method } = meta ?? {};
    const requestMethod = method ?? "get";
    const queryFilters = generateFilter(filters);
    const query = {};
    if (mode === "server") {
      query._start = (currentPage - 1) * pageSize;
      query._end = currentPage * pageSize;
    }
    const generatedSort = generateSort(sorters);
    if (generatedSort) {
      const { _sort, _order } = generatedSort;
      query._sort = _sort.join(",");
      query._order = _order.join(",");
    }
    const combinedQuery = { ...query, ...queryFilters };
    const urlWithQuery = Object.keys(combinedQuery).length ? `${url}?${(0, import_query_string.stringify)(combinedQuery)}` : url;
    const { data, headers } = await httpClient[requestMethod](urlWithQuery, {
      headers: headersFromMeta
    });
    const total = +headers["x-total-count"];
    return {
      data,
      total: total || data.length
    };
  },
  getMany: async ({ resource, ids, meta }) => {
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "get";
    const { data } = await httpClient[requestMethod](
      `${apiUrl}/${resource}?${(0, import_query_string.stringify)({ id: ids })}`,
      { headers }
    );
    return {
      data
    };
  },
  create: async ({ resource, variables, meta }) => {
    const url = `${apiUrl}/${resource}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "post";
    const { data } = await httpClient[requestMethod](url, variables, {
      headers
    });
    return {
      data
    };
  },
  update: async ({ resource, id, variables, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "patch";
    const { data } = await httpClient[requestMethod](url, variables, {
      headers
    });
    return {
      data
    };
  },
  getOne: async ({ resource, id, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "get";
    const { data } = await httpClient[requestMethod](url, { headers });
    return {
      data
    };
  },
  deleteOne: async ({ resource, id, variables, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "delete";
    const { data } = await httpClient[requestMethod](url, {
      data: variables,
      headers
    });
    return {
      data
    };
  },
  getApiUrl: () => {
    return apiUrl;
  },
  custom: async ({
    url,
    method,
    filters,
    sorters,
    payload,
    query,
    headers
  }) => {
    let requestUrl = `${url}?`;
    if (sorters) {
      const generatedSort = generateSort(sorters);
      if (generatedSort) {
        const { _sort, _order } = generatedSort;
        const sortQuery = {
          _sort: _sort.join(","),
          _order: _order.join(",")
        };
        requestUrl = `${requestUrl}&${(0, import_query_string.stringify)(sortQuery)}`;
      }
    }
    if (filters) {
      const filterQuery = generateFilter(filters);
      requestUrl = `${requestUrl}&${(0, import_query_string.stringify)(filterQuery)}`;
    }
    if (query) {
      requestUrl = `${requestUrl}&${(0, import_query_string.stringify)(query)}`;
    }
    let axiosResponse;
    switch (method) {
      case "put":
      case "post":
      case "patch":
        axiosResponse = await httpClient[method](url, payload, {
          headers
        });
        break;
      case "delete":
        axiosResponse = await httpClient.delete(url, {
          data: payload,
          headers
        });
        break;
      default:
        axiosResponse = await httpClient.get(requestUrl, {
          headers
        });
        break;
    }
    const { data } = axiosResponse;
    return Promise.resolve({ data });
  }
});

// src/index.ts
var src_default = dataProvider;
//# sourceMappingURL=index.cjs.map