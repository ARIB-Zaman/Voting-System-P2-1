// src/index.ts
import { stringify as stringify2 } from "query-string";

// src/provider.ts
import { stringify } from "query-string";

// src/utils/mapOperator.ts
var mapOperator = (operator) => {
  switch (operator) {
    case "ne":
    case "gte":
    case "lte":
      return `_${operator}`;
    case "contains":
      return "_like";
    default:
      return "";
  }
};

// src/utils/generateSort.ts
var generateSort = (sorters) => {
  if (sorters && sorters.length > 0) {
    const _sort = [];
    const _order = [];
    sorters.map((item) => {
      _sort.push(item.field);
      _order.push(item.order);
    });
    return {
      _sort,
      _order
    };
  }
  return;
};

// src/utils/generateFilter.ts
var generateFilter = (filters) => {
  const queryFilters = {};
  if (filters) {
    filters.map((filter) => {
      if (filter.operator === "or" || filter.operator === "and") {
        throw new Error(
          `[@refinedev/simple-rest]: \`operator: ${filter.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`
        );
      }
      if ("field" in filter) {
        const { field, operator, value } = filter;
        if (field === "q") {
          queryFilters[field] = value;
          return;
        }
        const mappedOperator = mapOperator(operator);
        queryFilters[`${field}${mappedOperator}`] = value;
      }
    });
  }
  return queryFilters;
};

// src/utils/axios.ts
import axios from "axios";
var axiosInstance = axios.create();
axiosInstance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    var _a, _b, _c;
    const customError = {
      ...error,
      message: (_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message,
      statusCode: (_c = error.response) == null ? void 0 : _c.status
    };
    return Promise.reject(customError);
  }
);

// src/provider.ts
var dataProvider = (apiUrl, httpClient = axiosInstance) => ({
  getList: async ({ resource, pagination, filters, sorters, meta }) => {
    const url = `${apiUrl}/${resource}`;
    const {
      currentPage = 1,
      pageSize = 10,
      mode = "server"
    } = pagination ?? {};
    const { headers: headersFromMeta, method } = meta ?? {};
    const requestMethod = method ?? "get";
    const queryFilters = generateFilter(filters);
    const query = {};
    if (mode === "server") {
      query._start = (currentPage - 1) * pageSize;
      query._end = currentPage * pageSize;
    }
    const generatedSort = generateSort(sorters);
    if (generatedSort) {
      const { _sort, _order } = generatedSort;
      query._sort = _sort.join(",");
      query._order = _order.join(",");
    }
    const combinedQuery = { ...query, ...queryFilters };
    const urlWithQuery = Object.keys(combinedQuery).length ? `${url}?${stringify(combinedQuery)}` : url;
    const { data, headers } = await httpClient[requestMethod](urlWithQuery, {
      headers: headersFromMeta
    });
    const total = +headers["x-total-count"];
    return {
      data,
      total: total || data.length
    };
  },
  getMany: async ({ resource, ids, meta }) => {
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "get";
    const { data } = await httpClient[requestMethod](
      `${apiUrl}/${resource}?${stringify({ id: ids })}`,
      { headers }
    );
    return {
      data
    };
  },
  create: async ({ resource, variables, meta }) => {
    const url = `${apiUrl}/${resource}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "post";
    const { data } = await httpClient[requestMethod](url, variables, {
      headers
    });
    return {
      data
    };
  },
  update: async ({ resource, id, variables, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "patch";
    const { data } = await httpClient[requestMethod](url, variables, {
      headers
    });
    return {
      data
    };
  },
  getOne: async ({ resource, id, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "get";
    const { data } = await httpClient[requestMethod](url, { headers });
    return {
      data
    };
  },
  deleteOne: async ({ resource, id, variables, meta }) => {
    const url = `${apiUrl}/${resource}/${id}`;
    const { headers, method } = meta ?? {};
    const requestMethod = method ?? "delete";
    const { data } = await httpClient[requestMethod](url, {
      data: variables,
      headers
    });
    return {
      data
    };
  },
  getApiUrl: () => {
    return apiUrl;
  },
  custom: async ({
    url,
    method,
    filters,
    sorters,
    payload,
    query,
    headers
  }) => {
    let requestUrl = `${url}?`;
    if (sorters) {
      const generatedSort = generateSort(sorters);
      if (generatedSort) {
        const { _sort, _order } = generatedSort;
        const sortQuery = {
          _sort: _sort.join(","),
          _order: _order.join(",")
        };
        requestUrl = `${requestUrl}&${stringify(sortQuery)}`;
      }
    }
    if (filters) {
      const filterQuery = generateFilter(filters);
      requestUrl = `${requestUrl}&${stringify(filterQuery)}`;
    }
    if (query) {
      requestUrl = `${requestUrl}&${stringify(query)}`;
    }
    let axiosResponse;
    switch (method) {
      case "put":
      case "post":
      case "patch":
        axiosResponse = await httpClient[method](url, payload, {
          headers
        });
        break;
      case "delete":
        axiosResponse = await httpClient.delete(url, {
          data: payload,
          headers
        });
        break;
      default:
        axiosResponse = await httpClient.get(requestUrl, {
          headers
        });
        break;
    }
    const { data } = axiosResponse;
    return Promise.resolve({ data });
  }
});

// src/index.ts
var src_default = dataProvider;
export {
  axiosInstance,
  src_default as default,
  generateFilter,
  generateSort,
  mapOperator,
  stringify2 as stringify
};
//# sourceMappingURL=index.mjs.map